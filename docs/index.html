<!doctype html><head><meta charset="utf-8"><meta name="viewport" content="width=1200"><script src="https://distill.pub/template.v2.js"></script><style>d-title h1, d-title p, d-title figure {
  grid-column: page;
}

/* table of contents */

@media (max-width: 1000px) {
  d-contents {
    justify-self: start;
    align-self: start;
    grid-column-start: 2;
    grid-column-end: 6;
    padding-bottom: 0.5em;
    margin-bottom: 1em;
    padding-left: 0.25em;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    border-bottom-width: 1px;
    border-bottom-style: solid;
    border-bottom-color: rgba(0, 0, 0, 0.1);
  }
}

@media (min-width: 1000px) {
  d-contents {
    align-self: start;
    grid-column-start: 1;
    grid-column-end: 4;
    justify-self: end;
    padding-right: 3em;
    padding-left: 2em;
    border-right: 1px solid rgba(0, 0, 0, 0.1);
    border-right-width: 1px;
    border-right-style: solid;
    border-right-color: rgba(0, 0, 0, 0.1);
  }
}

@media (min-width: 1180px) {
  d-contents {
    grid-column-start: 1;
    grid-column-end: 4;
    justify-self: end;
    padding-right: 3em;
    padding-left: 2em;
    border-right: 1px solid rgba(0, 0, 0, 0.1);
    border-right-width: 1px;
    border-right-style: solid;
    border-right-color: rgba(0, 0, 0, 0.1);
  }
}

d-contents nav h3 {
  margin-top: 0;
  margin-bottom: 1em;
}

d-contents nav a {
  color: rgba(0, 0, 0, 0.8);
  border-bottom: none;
  text-decoration: none;
}

d-contents li {
  list-style-type: none;
}

d-contents ul {
  padding-left: 1em;
}

d-contents nav ul li {
  margin-bottom: 0.25em;
}

d-contents nav a:hover {
  text-decoration: underline solid rgba(0, 0, 0, 0.6);
}

d-contents nav ul {
  margin-top: 0;
  margin-bottom: 6px;
}

d-contents nav > div {
  display: block;
  outline: none;
  margin-bottom: 0.5em;
}

d-contents nav > div > a {
  font-size: 13px;
  font-weight: 600;
}

d-contents nav > div > a:hover, d-contents nav > ul > li > a:hover {
  text-decoration: none;
}

    #panel-layout {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-column-gap: 1%;
	grid-template-areas: ". a b"
}

#panel-left {
	grid-area: a;
}

#panel-right {
	grid-area: b;
}

.panel-controls {
	display: flex;
	justify-content: space-between;
}

.left-controls {
	flex: 1;
	margin-left: 10px;
}

.center-controls {
	flex: 1;
	text-align: center;
}

.right-controls {
	flex: 1;
	margin-right: 10px;
	text-align: right;
}

/* Line of subpanels */
.panel-grid-1-3 .subpanels-div, .panel-grid-1-4 .subpanels-div {
	display: flex;
}

.panel-grid-1-3 .subpanel, .panel-grid-1-4 .subpanel {
	flex: 1;
	margin: 10px;
}

.panel-grid-2-2 .subpanels-div {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-around;
}

.panel-grid-2-2 .subpanel {
	width: calc(50% - 20px);
	margin-top: 20px;
}

/* Allow a subpanel to better position sections of concatenated images */
.subpanel-image {
	overflow: hidden;
}
.subpanel-image img{
	position: relative;
	width: 1000%;
}

.control-icon {
	border-radius: 50%;
}

.control-icon svg {
	width: 25px;
}

.material-icons.md-18 {
	font-size: 18px;
}

.subpanel hr {
	margin-top: 5px;
	margin-bottom: 5px;
	color: black;
}

#saliency-legend {
	display: flex;
}

#saliency-legend-graphic {
	margin-left: 6px;
	flex: 1;
}

#saliency-color-labels {
	/* flex: 1; */
	display: flex;
	font-size: 50%;
	font-weight: bold;
	/* This is not a good way to do this */
	max-height: 20px;
	margin-top: -15px;
}

#saliency-color-label-left {
	flex: 1;
	text-align: left;
}

#saliency-color-label-center {
	flex: 1;
	text-align: center;
}

#saliency-color-label-right {
	flex: 1;
	text-align: right;
}

#panel-cluster {
	margin-bottom: 10px;
}
/* Filters */
.filters {
	margin-bottom: 10px;
}
.filters input{
	width: 6ch;
}

/* Tooltip CSS (copied from tippy.js/dist/tippy.css to avoid weird webpack css-loader issues) */
.tippy-box[data-animation=fade][data-state=hidden] {
	opacity: 0
}

[data-tippy-root] {
	max-width: calc(100vw - 10px)
}

.tippy-box {
	position: relative;
	background-color: #333;
	color: #fff;
	border-radius: 4px;
	font-size: 14px;
	line-height: 1.4;
	white-space: normal;
	outline: 0;
	transition-property: transform, visibility, opacity
}

.tippy-box[data-placement^=top]>.tippy-arrow {
	bottom: 0
}

.tippy-box[data-placement^=top]>.tippy-arrow:before {
	bottom: -7px;
	left: 0;
	border-width: 8px 8px 0;
	border-top-color: initial;
	transform-origin: center top
}

.tippy-box[data-placement^=bottom]>.tippy-arrow {
	top: 0
}

.tippy-box[data-placement^=bottom]>.tippy-arrow:before {
	top: -7px;
	left: 0;
	border-width: 0 8px 8px;
	border-bottom-color: initial;
	transform-origin: center bottom
}

.tippy-box[data-placement^=left]>.tippy-arrow {
	right: 0
}

.tippy-box[data-placement^=left]>.tippy-arrow:before {
	border-width: 8px 0 8px 8px;
	border-left-color: initial;
	right: -7px;
	transform-origin: center left
}

.tippy-box[data-placement^=right]>.tippy-arrow {
	left: 0
}

.tippy-box[data-placement^=right]>.tippy-arrow:before {
	left: -7px;
	border-width: 8px 8px 8px 0;
	border-right-color: initial;
	transform-origin: center right
}

.tippy-box[data-inertia][data-state=visible] {
	transition-timing-function: cubic-bezier(.54, 1.5, .38, 1.11)
}

.tippy-arrow {
	width: 16px;
	height: 16px;
	color: #333
}

.tippy-arrow:before {
	content: "";
	position: absolute;
	border-color: transparent;
	border-style: solid
}

.tippy-content {
	position: relative;
	padding: 5px 9px;
	z-index: 1
}</style><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><script defer="defer" src="index.bundle.js"></script></head><body><d-front-matter><script type="text/json">{
    "title": "Work in progress",
    "description": "Work in progress.",
    "authors": [
        {
            "author": "Lee Sharkey",
            "authorURL": "https://leesharkey.github.io/",
            "affiliation": "ETH Zurich and University of Zurich",
            "affiliationURL": "https://openai.com"
        },
        {
            "author": "Daniel Braun",
            "authorURL": "https://schubert.io/",
            "affiliation": "University of Sydney",
            "affiliationURL": "https://google.com"
        },
        {
            "author": "Full author list TBD",
            "authorURL": "https://schubert.io/",
            "affiliation": "University of Sydney",
            "affiliationURL": "https://google.com"
        }
    ],
    "katex": {
        "delimiters": [
            {
                "left": "$",
                "right": "$",
                "display": false
            },
            {
                "left": "$$",
                "right": "$$",
                "display": true
            }
        ]
    }
}</script></d-front-matter><d-title><h1>THIS IS AN UNFINISHED DRAFT COPY. Saliency as causality: Interpreting the neural mechanisms of RL agent behaviour</h1><p>We show that simulating an agent's environment within a neural network enables the use of gradients to study the causal mechanisms of the agent's behaviour.</p></d-title><d-article><i>TODO: Headline Figure: CoinRun: What we see; What the agent sees; Our generative model that simulates the agent inside the environment; Saliency map of what causes agent to take action at timestep t.</i><d-contents><nav class="l-text figcaption"><h3>Contents</h3><div><a href="#introduction">Introduction</a></div><div><a href="#coinrun">A recurrent environment simulator</a></div><div><a href="#analysis">Feature visualisation for recurrent agents</a></div><div><a href="#diversity-hypothesis">Dissecting the causal mechanisms of behaviour</a></div><div><a href="#feature-visualization">Validating our interpretations through interventions</a></div><div><a href="#attribution">Discussion</a></div><ul><li><a href="#dissecting-failure">Limitations of our method</a></li><li><a href="#hallucinations">New possibilities</a></li></ul><div><a href="#appendix">Appendix</a></div></nav></d-contents><div id="introduction"><p>The last half-decade has seen deep reinforcement learning (RL) agents learn to solve many exciting tasks, from beating humans in Go and Starcraft to solving Rubix cubes with a robotic hand. As real-world deployment of RL agents grows, there's an increasing need to understand the causal mechanisms of their behaviours<d-cite key="deletang2021"></d-cite>. This means looking inside their neural networks. But unlike convolutional image classifier networks, there has been much less success in interpreting the representations learned by deep RL agents. Why is analyzing the networks of RL agents so different?</p><p>Causality provides a useful lense to understand the difficulty. In a standard feedforward network, the pattern of activations in one layer <i>cause</i> the particular pattern of activations in the next layer up, and so on through the network, from inputs to outputs. Because neural networks are fully differentiable, if we want to understand what inputs cause a neuron x to maximally light up in a feedforward network, we can backpropagate gradients of neuron x's activation (with respect to the inputs) through the layers to probe which inputs are most responsible for neuron x's activation. This tool is used in feature visualisation and attribution maps (cite featviz; building blocks). In a sense, backpropagation of gradients lets us trace causality back through the layers of the network.</p></div><figure><video style="width: 100%;" loop controls muted><source src="videos/sample_0_50000_1.mp4" type="video/mp4"></video><figcaption style="text-align: center;"><ul><li>TODO: Footnote: Given that many modern deep RL agents use recurrent neural networks, it's worthwhile to note that these methods work in principle even for recurrent networks thanks to BPTT.</li><li>TODO: Figure: an animated diagram of a csonv net activating one layer then activating the next.</li><li>TODO: Another diagram that shows a visualisation of the maximally exciting image..</li></ul></figcaption></figure><div><p>By contrast to standard neural networks, deep RL agents are situated <i>in an environment</i>. We can't use the same trick for RL agents because causality flows forward through both the agent's neural networks <i>and</i> its environment. For example: If an agent presses a lightswitch, causing a light to turn on, the agent's action caused its visual neurons to activate even though there are no 'action-neuron-to-visual-neuron' connections. The causality flowed through the environment, not through the agent's internal memory. When causality flows through the environment, we call this `external memory'.</p></div><figure><div id="mdp-animation"></div><div id="mdp-animation-grad"></div><figcaption style="text-align: center;"><ul><li>TODO: Footnote: ref to external memory and autostigmergy.</li><li>TODO: An animated diagram of an MDP graph where each node is lighting up consecutively.</li></ul></figcaption></figure><div><p>In most cases, the environment is not differentiable. This means we can't use gradient-based methods to ask what causes a neuron in a deep RL agent to have a particular activation at a particular timestep. To complicate matters further, we don't just want to study single neurons at single timesteps; what we actually want to understand in RL agents is the causal (neural) mechanisms of behaviour, where behaviour is a <i>sequence</i> of actions in a particular environmental context.</p></div><figure><video style="width: 100%;" loop controls muted><source src="videos/sample_0_50000_1.mp4" type="video/mp4"></video><figcaption style="text-align: center;"><ul><li>TODO: Footnote: Justifying definition of behaviour. robot hand crushing human or grabbing pencil.</li><li>TODO: A diagram illustrating a theoretical case of autostig where the MDP diagram only lights up the env nodes.</li></ul></figcaption></figure><div><p>Previous work has skirted around these issues, typically by:</p><ul><li>Avoiding studying neural causal mechanisms entirely and focusing on external causes (cite Deletang);</li><li>Focusing on studying the neural causal mechanisms of single actions at single timesteps (cite Rupprecht)</li><li>Studying only the convolutional vision networks of feedforward (not recurrent) agents, without regard for understanding how behaviour is organised <i>through time</i> and without regard for the representations that link what the agent sees to how it acts.</li></ul>Previous work therefore fails to explain the causal neural mechanisms of agent behaviour.<p></p><p>In this article we address these issues. We first train a differentiable simulator of the environment in a recurrent neural network (cite Chiappa). This permits us to backpropagate gradients backwards through time, through both the environment and the agent (if the agent is recurrent). In turn, this permits the use of gradient-based causal attribution maps to generate explanations of the neural mechanisms of RL agents' behaviour. We believe that making gradient-based interpretability methods applicable to RL agents will be as important for understanding the neural activity of agents as they have been for understanding convolutional image classifiers. Our investigation motivates a shift of focus from a purely static feature-based interpretation of RL agent's networks toward a dynamics-based interpretation. To demonstrate the validity of the interpretations of the agent's neural activity that our method produced, we also manually modify the agents' neural dynamics and predict the changes in behaviour that were caused by our modifications.</p></div><h2>Results</h2><h3>Simulating the environment in a recurrent network</h3><div><p>We developed a solution to agent interpretability that works in any environment (in practice, some environments may require too much computation). We trained a generative model to simulate the MDP, permitting us to study how agents use internal and external memory to organise behaviour. It's a VAE that simulates agent-environment rollouts... etc.</p><p>The agent is a component of the VAE decoder. But while the VAE is training, the agent's weights are fixed, so in the decoder only the environment dynamics are learned. The actions produced by the agent influence the how the environment unrolls. The environment dynamics are independent of the specific agent used in the decoder, demonstrated in figXXX where we use a trained vs untrained agent. In the third panel the agent isnt even implemented by a neural network - it is hardcoded only to chooses "jump right". In all cases, the environment dynamics remain roughly realistic. This is important for preserving external memory in cases where the agent uses it to control its behaviour. While there are similarities, our approach stands in contrast to recent model-based RL approaches train a environment model so that the agent can use it in order to represent latent environmental variables (cite Ha and Schmidhuber 2018) or to plan (cite Buesing et al. 2018; Hafner et al. 2018/2020, other refs). Instead, the environment model we train is separate from the agent and is not how the agent represents the world or selects its actions. It is a stand-in for the external environment that the agent was trained in; less a 'mental model of the world', more 'The Matrix'.</p></div><figure><img src="diagrams/architecture_diagram.png" alt="VAE Architecture Diagram"><figcaption style="text-align: center;">TODO: Figure that depicts the architecture. It would be nice if it were animated, but not essential.</figcaption></figure><h3>Optimising generated samples to maximise/minimise certain neurons' activity</h3><div><p>This builds on previous work that use generative visualisation to understand RL agents (cite Rupprecht). But previous work only generated single image frames, not image sequences, and therefore could not be used to interpret how behaviour is coordinated through time.</p><p>Since the generative model is fully differentiable, we can optimise the VAE latent space vector used by the generator generates the samples so that they have certain interesting properties, such as cases where the agent experiences large drops in value (unexpected failures) or cases where the agent takes specific sequences of actions (like consistently moving backwards).</p></div><figure><video style="width: 100%;" loop controls muted><source src="videos/sample_0_50000_1.mp4" type="video/mp4"></video><figcaption style="text-align: center;">TODO: Figure that depicts samples that have been optimized for different target functions. This can be a panel so that a user can just select the target function name and see the associated videos. Should include hx neuron target function samples discussed below. The hx neuron target functions should be the default display.</figcaption></figure><div><p>We can even optimize the activity of hidden state neurons such that they are maximally or minimally activated, a method as is commonly used to interpret vision networks. But when we do this, we find that most neurons in the agent's hidden state are difficult to interpret. It's not clear what they encode. This hints at important differences between the interpretation of RL agents and convolutional networks.</p><p>When representations associated with RL (task representations) have been studied in neuroscience, they have exhibited strong 'mixed-selectivity' - they appear to be selective for multiple task features (cite papers from review). Features in the input tend to activate <i>groups of neurons</i>, also called <i>directions in neural statespace</i>. Dimensionality reduction techniques can help identify those directions in neural statespace. PCA, the dimensionality reduction method that we use here, can intuitively be thought of as identifying the groups of neurons that most commonly fire together. Stated more accurately, PCA identifies the directions in neural statespace that explain most of the variance of their firing.</p></div><figure class="l-screen"><div id="panel"></div><figcaption style="text-align: center;">MAIN PANEL.</figcaption></figure><div><p>When we generate agent-environment rollouts that maximally activate agent's hidden state neurons in the directions of the ICs, we find that the visualisations look more meaningful. Here we find directions that appear to correspond to XYZ.</p></div><h3>Using saliency to dissect the causal mechanisms of behaviour</h3><div><p>So far, the evidence that indicates that certain directions in neural statespace represent certain task features has been correlative. We want to be able to tell if the features we've identified actually <i>cause</i> the activity to move in that direction in neural statespace. In neuroscience, showing causation is usually difficult and requires interventional experiments. But in our generative model, it is easy; we can use attribution/saliency maps. Saliency maps identify how much each input or neuron causes downstream neuron to fire. We can therefore explore causality in our simulated system by analysing the gradients of certain neurons with respect to others.</p><p>For example, we can measure how much each directions in the agent's neural statespace contributes to a particular action by measuring the alignment of the saliency vector with that statespace direction. Blue colours mean those directions (groups of neurons) positively contributed to that action, and red colours indicate negative contributions.</p></div><div><p>We've just shown how directions in the agent's neural state space causally respond to observations of specific features in the environment. But the hidden state does more than respond to what the agent sees - it also determines behaviour. We can identify how much an action a certain timestep is caused by observations of components of the agent's neural statespace (figxxx). These samples depict an agent that jumps over a buzzsaw in the 20th timestep. The saliency plots depict the contribution of the observation and the directions in the agent's neural statespace to that action. We can see by the saliency map that the buzzsaw contributes to the jumping action just before the jump. The buzzsaw-selective direction in neural statespace also contributes to the jumping action.</p></div><div><p>Behaviours are more than single actions - they are a sequence of actions in a particular environmental context. In our generative model, behaviours can be described by sequences of vectors: the activities of the environment simulator network and action logits in sequential timesteps. We can therefore describe behaviours by a canonical set of vectors averaged over many instances of such behaviours. If we measure the contribution of observation pixels and agent hidden state directions to the alignment of the environment activity vectors and action vectors with the vectors that are canonical of that behaviour, we can determine how much they 'caused' that behaviour.</p><p>Consider the behaviour "jumping onto a chasm island" (TODO story text here and describe figure)</p><h3>Validating our interpretations by modifying the agent's neural dynamics</h3><div><p>Our understanding of a neural network is only as good as the predictions it enables us to make about it. We therefore tried to predictably control the agent's behaviour. To do this, we 'swap' certain directions in the agent's neural statespace: for example, at any timestep where the agent's networks cause its hidden state to move in the direction of the buzzsaw-representation, we instead move it in the direction of the box-representation.</p></div><div><p>It is safe for the agent to land on boxes, but the agent dies if it lands on buzzsaws. In samples where the buzzsaw direction is swapped for the box direction, we see that the agent jumps onto buzzsaws much more often.</p><i>TODO: Statistics. Maybe a bar chart to depict. % of samples with deaths by buzzsaw. % of episodes of where the agent jumps on a box. Both stats with and without swap of buzzsaw direction and box direction.</i></div><div><p>Similarly, when we replace the chasm-with-island direction with the chasm direction, the agent dies by jumping into chasms much more often, as would be expected if the agent thought it were going to land safely on an island.</p><i>TODO: Statistics. Maybe a bar chart to depict. % samples where the agent dies by falling into chasms. % samples where agent lands on an chasm island. Both stats with and without swap of buzzsaw direction and box direction.</i></div><h2>Discussion</h2><div><p>Using a generative environment simulation, we have begun to understand the neural dynamics that govern the behaviour of a simple deep RL agent. Importantly, we have been able to identify the <i>causal</i> components of these dynamics and use our understanding to predict the results of modifications to the agent.</p><p>In line with previous work (cite Activation atlases, that French author, anything in the review on point), we found that combining several interpretability methods together has yielded much deeper understanding than any individual method alone. Chiming with other work (cite activation atlases, Hilton, etc), we have found two combinations to be particularly useful: 1) combining dimensionality reduction methods with saliency maps and 2) combining saliency maps with generative feature visualization. We believe that finding other useful combinations of interpretability methods is an exciting avenue of future research.</p><p>At least for RL agents, our investigation motivates a shift of focus from a purely-feature based interpretation of a neural network toward dynamics-based interpretation of RL agents' networks. We also highlight the necessity of studying both internal and external memory for understanding the causal mechanisms of agent behaviour. We believe these emphases will be important to ensure that our interpretations of RL agents do not contain blind-spots.</p><p>Our method has limitations:</p><ul><li><p><strong>Learning an environment simulator can be a challenge</strong>: It may be hard to simulate all environments well enough for this method to work. Indeed, we made the simulator&#39;s job easier by turning off the background images so that the backgrounds were only black. Even then, samples from our simulator exhibit some imperfections such as resumption after reaching the coin. And games with richer environmental dynamics, such as CaveFlyer, looked out of reach of a model of our size, though we did not train a CaveFlyer-environment simulator to completion. However, our environment simulator (an LSTM with 1024 units with a shallow unsampling convolutional decoder) is relatively small and architecturally primitive; it is very likely possible to train better environment simulators using more modern architectures.</p></li><li><p><strong>Deterministic dynamics</strong>: The simulations generated here explore only deterministic sequences of modal actions. They therefore do not explore behaviour that may be non-modal, which may therefore exclude a potentially large proportion of important behaviours.</p></li><li><p><strong>Other agents</strong>: The method we propose here works for agents that are fully differentiable (since we pass gradients through the stochastic sampling of actions). It might not be as straightforward to adapt the method to agents with non-differentiable components, such as those that use symbolic components.</p></li></ul><p>Despite these limitations, the approach opens up many exciting new possibilities for deep RL agent interpretation:</p><ul><li><p><strong>Layer-by-layer analysis</strong>: Here we focused our analyses only on the agent&#39;s hidden state. This is only one layer of the agent. Generative visualisation has been used to build up a layer-wise understanding of convolutional image classifier networks and the same is possible here. Understanding all of the layers of the agent (and to some extent the environment simulator) is necessary to understand how the agent transforms its various inputs within and across timesteps to compute its behaviour.</p></li><li><p><strong>Safe training and un-training of the agent:</strong> While training our generative model, we kept the weights of the agent fixed and trained only the weights of the environment simulator. But it is also possible to fix the weights of the environment simulator and retrain the agent. If we can identify undesirable behaviours exhibited by the agent in simulation (for example by optimizing for generating samples where the agent assigns high value to states humans deem bad), we may be able to retrain the agent by generating examples of that behaviour and penalizing the agent from within the safety of the simulation.</p></li><li><p><strong>Scaling to more complex agents and tasks</strong>: The agent and task-environment studied here, although non-trivial, are nevertheless simple compared with what is possible. Larger agents trained on more interesting and complicated tasks may yield more interesting task representations. Although we mentioned scaling as a potential limitation, there is nevertheless hope for scaling our method to highly capable future agents. One source of hope is the representational capacity of large networks seems capable of learning surprisingly rich representations of the world. Another potential source of hope is that future agents may well be model-based and therefore learn their own model of the environment. We may be able to leverage their internal world model to supplement the external environment simulator; we may therefore need only to train an external environment simulator to learn the inaccuracies in the agents&#39; world model and learn to represent those environmental variables that the agent is using as external memory. The method may thus scale with the capability of the agent.</p></li><li><p><strong>Artificial neuroethology</strong>: The behaviours we analyzed here were chosen by hand, but it would be better to systematically identify behaviours using unsupervised learning so that we can comprehensively study their neural mechanisms. This endeavour has a name: artificial neuroethology (cite Beer, Cliff, Merel etc). The method proposed here has all the necessary ingredients to do so: representations of environmental variables, actions, and agent neural activity. And, perhaps for the first time, we also have a straightforward way to identify the environmental variables that are causally relevant for agent behaviour -- saliency maps over dimensions of the environment representation.</p></li><li><p><strong>A tool for neuroscience</strong>: Computational neuroscientists often study the solutions learned by artificial neural networks in order to generate hypotheses about the solutions to tasks learned by animals. But studying the causal structure of the solutions learned by artificial RL agents has been a challenge due to the non-differentiability of the environment. Our method offers a way to study the solutions to naturalistic (deterministic) tasks that artificial agents learn, which will serve as a useful tool for neuroscientific hypothesis generation.</p></li><li><p><strong>Training agents in natively differentiable environments</strong>: Given the potential difficulty of training environment simulations for more complex environments, we may be better to work with agents that are trained in environments that are designed to be differentiable (cite), since our approach suggests that environment differentiability is useful for agent interpretation.</p></li></ul><h1>End of article</h1><h2>Just retaining the below hints because they'll probably be useful as a reference.</h2><h4>Hot reloading</h4><p>Your browser can automatically refresh when your editor saves. This should work by default, and you can disable it in <code>index.js</code>. Sometimes hot reloading isn't fully compatible with all types of code, so you may need to try manually reloading if you're seeing inconsistent behavior.</p><h4>Formulas</h4><p>Here's a test of an inline equation<d-math>c = a^2 + b^2</d-math>. Can also be used with configurable katex settings, for example by using inline <code>$</code> signs:<d-math>x^2</d-math>. There are also block equations:</p><d-math block="">c = \pm \sqrt{ \sum_{i=0}^{n}{a^{222} + b^2}}</d-math><h4>Citations</h4><p>We can<d-cite key="mercier2011humans"></d-cite>also cite<d-cite key="gregor2015draw,mercier2011humans,openai2018charter"></d-cite>external publications.<d-cite key="dong2014image,dumoulin2016guide,mordvintsev2015inceptionism"></d-cite>. We should also be testing footnotes<d-footnote id="d-footnote-1">This will become a hoverable footnote. This will become a hoverable footnote. This will become a hoverable footnote. This will become a hoverable footnote. This will become a hoverable footnote. This will become a hoverable footnote. This will become a hoverable footnote. This will become a hoverable footnote.</d-footnote>. There are multiple footnotes, and they appear in the appendix<d-footnote id="d-footnote-2">Given I have coded them right. Also, here's math in a footnote:<d-math>c = \sum_0^i{x}</d-math>. Also, a citation. Box-ception<d-cite key="gregor2015draw"></d-cite>!</d-footnote>as well.</p></div></div></d-article><d-appendix id="appendix"><h3>Acknowledgments</h3><p>We are deeply grateful to...</p><p>Many of our diagrams are based on...</p><h3>Author Contributions</h3><p><b>Research:</b> Alex developed ...</p><p><b>Writing & Diagrams:</b> The text was initially drafted by...</p><d-footnote-list></d-footnote-list><d-citation-list></d-citation-list></d-appendix><d-bibliography src="bibliography.bib"></d-bibliography></body>